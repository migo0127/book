# 設計模式

## 設計原則

設計模式，如其名，先有設計，再有模式。

模式是對一些常用設計的總結與提煉，設計想法對模式的形成具有指導意義。



### 用模式思考的過程

(圖) 解決方案的高層視圖

![image-20240322172636269](/Users/migo.weng/Library/Application Support/typora-user-images/image-20240322172636269.png)

​																										

> 用模式思考的過程
>
> 1. 找出模式：在問題領域中找出模式。
>
> 2. 分析和應用模式：對於要進行分析的模式集合，執行步驟 2a ~ 2d。
>
>    2a. 依背景的創造順序將模式排序：
>
>    ​	根據為其他模式創造背景的情況將模式排序。其原理是，一個模式將為另一個模式創造背	景，不會出現兩個模式互為彼此建立背景的情況。
>
>    2b. 選擇模式並擴展設計：
>
>    ​	根據排序，選擇清單中的下一個模式，用它得到高層的概念設計。
>
>    2c. 找到其它模式：
>
>    ​	找到在分析中可能出現的其他模式，將它們增加到要分析的模式集合中。
>
>    2d. 重複：
>
>    ​	對還沒有融入概念設計的模式重複以上步驟。
>
> 3. 增加細節：根據設計的需要增加細節。擴展方法和類別的定義。

只有能夠用模式來理解整個問題領域時，這種方法才可以發揮作用。而且雖然它並非總是能奏效，但是它為我們提供了很好的起點。設計模式最有用的地方，可能就是提供了著手的方法。



### SOLID原則

1. Single Responsibility Principle：單一職責原則（SRP）。
2. Open-Close Principle：開放封閉原則（OCP）。
3. Liskov Subsitution Principle：里氏替換原則（LSP）。
4. Interface Segregation Principle：介面分離原則（LSP）。
5. Dependency Inversion Principle：依賴倒置原則（IDP）。



## 設計模式的分類

在《設計模式：可重複使用物件導向軟體的基礎》一書中定義了 23 種設計模式，同時根據其設計意圖又可分為三個大類：

- 創建型設計模式（5 種）：

  創建型模式提供創建物件的機制，抽象化了實例化的過程，將物件的創建和創建的過程細結進行了分離。。

- 結構型設計模式（7 種）：

  結構型模式是介紹如何將「類別」或「物件」結合在一起，組合成功能更強大的結構，從而實現一定的設計目標。

- 行為型設計模式（11 種）：

  行為模式負則對象之間的溝通與職責劃分，其除了關注結構以外，更關注他們之間的溝通機制。

  

### 創建型模式 Creational Pattern

> 用於管理物件的建立，實例化物件。

創建型模式提供創建物件的機制，抽象化了實例化的過程，將物件的創建和創建的過程細節進行了分離。使結構更加清晰，並符合單一職責原則（SRP）的設計思路。

其包含如下 5 種類型：

1. 單例模式（Singleton）：確保一個類別僅有一個實例存在。

2. 工廠方法模式（Factory Method）：定義一個創建物件的介面，但讓子類別決定實例化哪個類別。

3. 抽象工廠模式（Abstract Factory）：創造了相關物件（族）的集合。
4. 生成器模式（Builder）：將一個複雜的物件構建過程和表示分離，以便同一個構建過程可以創建不同的表示。
5. 原型模式（Prototype）：通過拷貝現有的物件來創建新的物件。



### 結構型模式 Structural Pattern

> 處理介面，將實例與抽象聯繫起來。

結構型模式是介紹如何將「類別」或「物件」結合在一起，組合成功能更強大的結構，從而實現一定的設計目標。類別、物件之間怎樣設計繼承、依賴、組合關係直接影響到整體程式的健壯性、可維護性。

其包含如下 7 種類型：

1. 外觀模式 （Facade）：能夠為使用類別 B 簡化已有系統 A。
2. 適配器模式（Adapter）：使已有的類別 A 能夠轉換成使用類別 B 所需的介面。
3. 橋接模式（Bridge）：允許一組相關的使用物件（抽象的具體類別）使用不同的實作。
4. 裝飾器模式（Decorator）：動態地將功能添加到物件上。
5. 代理模式（Proxy）：控制對其他物件的訪問。
6. 組合模式（Composite）：將物件組織成樹狀結構，以表示部分 - 整體的層次關係。
7. 享元模式（Flyweight）：將多個物件共享，以減少內存使用或提高性能。



### 行為型模式 Behavioral Pattern

> 封裝變化。

行為型模式負責對象之間的溝通與職責劃分，其除了關注結構以外，更關注他們之間的溝通機制。透過行為型模式可以更清楚的劃分類別、物件之間的職責，展現實例物件之間的作用互動。

其包含如下 11 種類型：

1. 策略模式（Strategy）：定義一系列算法，並使其可以互相替換。
2. 觀察者模式（Observer）：定義了物件之間的一對多依賴關係，這樣當一個物件的狀態發生改變時，所有依賴它的物件都得到通知並自動更新。
3. 模版方法模式（Template Method）：定義一個操作中的算法的骨架，而將一些步驟延遲到子類別中。
4. 命令模式（Command）：將請求封裝成物件，以便使用不同的請求、佇列或日誌來參數化其他物件。
5. 備忘錄模式（Memento）：在不違反封裝的情況下捕獲並保存一個物件的內部狀態，以便稍後可以將該物件恢復到原先的狀態。
6. 迭代器模式（Iterator）：提供一種方法來訪問一個聚合物件中各個元素，而不需要暴露其內部表示。
7. 中介者模式（Mediator）：定義了一個封裝了一組物件如何互相作用的物件。
8. 狀態模式（State）：允許一個物件在其內部狀態改變時改變其行為。
9. 職責鏈模式（Chain of Responsibility）：將請求的發送者和接收者解耦，以便多個物件都有機會處理這個請求。
10. 訪客模式（Visitor）：在不改變被操作物件的類別的前提下，定義作用於這些物件的新操作。
11. 解釋器模式（Interpreter）：給定一個語言，定義其文法的一個表示，並定義一個解釋器來解釋這個語言中的句子。



## 創建型模式

### 1. 單例模式（Singleton）



### 2. 工廠方法模式（Factory Method）

<img src="https://img-blog.csdnimg.cn/555a057e40144086bc58939bdcca94aa.png" alt="img" style="zoom:60%;" />

- 意圖

> 定義一個用於建立物件的接口，讓子類別決定實例化哪一個類別。Factory Method 使一個類別的實例化延遲到其子類別。

舉例子

1. 換燈泡

我自己在家換過燈泡，以前我家裡燈壞掉的時候，我看著這個奇形怪狀的燈管，心裡想，這種燈泡和這個燈座應該是一體的，市場上估計很難買到適配我這個燈座的燈泡了。結果等我把燈泡擰下來，跑到門口的五金店去換的時候，店員隨便給了我一個燈泡，我回去隨便擰了一下居然就能用了。

我買這個燈泡的過程就用到了工廠模式，而正是得益於這種模式，讓我可以方便在家門口就買到可以用的燈泡。



2. 卡牌對戰遊戲

卡牌對戰中，卡牌有一些基本屬性，例如攻防、生命值，也符合一些通用約定，例如一回合出擊一起等等，那麼對於戰鬥系統來說，應該怎樣實例化卡牌呢？如何批次操作卡牌，而不是通用功能也要拿到每個卡牌的實例才能呼叫？另外每張卡牌有特殊能力，這些特殊能力又該如何拓展呢？



3. 實現任意圖形拖曳系統

一個可以被交互操作的圖形，它可以用滑鼠進行拉伸、旋轉或移動，不同圖形實現這些操作可能並不相同，要存儲的數據也不一樣，這些數據應該獨立於圖形存儲，我們的系統如果要對接任意多的圖形，具備強大拓展能力，物件關係該如何設計？



- 意圖解釋

  > 定義一個用於建立物件的接口，讓子類別決定實例化哪一個類別。Factory Method 使一個類別的實例化延遲到其子類別。

  在使用工廠方法之前，我們就要闖建一個用於創建對象的接口，這個接口具備通用性，所以我們可以忽略不同的實現來做一些通用的事情。

  依換燈泡的例子來說，去門口五金店買燈泡，而不是拿到燈泡材料自己 New 一個出來，就是因為五金店這個 "工廠" 提供的燈泡符合國家接口標準，而家裡的燈座也符合這個標準，所以燈座不需要知道對接的燈泡是巨體哪個實例，什麼顏色、什麼形狀，這些都無所謂，只要燈泡符合國家標準接口，就可以對接上。

  依卡牌對戰的系統來說，所有卡牌都應該實現同一種接口，所以卡牌對戰系統拿到的卡牌應該就是簡單的 Card 類型，這種類型具備基本的卡片操作交互能力，系統就調用這些能力完成基本流程就好了，如果系統直接實例化具體的卡片，那麼不同的卡片類型會導致系統難以維護，卡片間操作也無法抽象化。正式這鞏模式，使得我們可以在卡牌的具體實現上做一些特殊功能，例如修改卡片攻擊時效果，修改卡牌銷毀時效果。

  依圖形拖曳系統來說，用到了「連接平行的類層次」這個特幸，所謂連接平行的類層次，就是指一個圖形與其對應的操作類是一個平行抽象類，而一個具體的圖形與具體的操作類別則是另一個平行關係，系統只要專注於最抽象的 "通用操作類別" 即可，操作時，底層可能是某個具體的 "圓類" 與 "圓操作類" 結合使用，具體的類別有不同的實現，但都符合同一種接口，因此操作系統才可以把它們一視同仁，統一操作。

  所以介面是非常重要的，工廠方法第一句話就是 "定義一個用於創建物件的介面"，這個介面就是 `Creator`，讓子類，也就是具體的創建類別 `ConcreteCreator` 決定要實例化哪個類別 `ConcreteProduct` 

  所謂使一個類別的實例化延遲到其子類，是因為抽象類別不知道要實例化哪個具體類別，所以實例化動作只能由具體的子類別去做，這樣繞一圈的好處是，可以將任意多物件看作是同一類事物，做統一的處理，比如無論何種燈泡實例都滿足通用的燈座接口，所有工廠實例化的卡牌都具備玩一局卡牌遊戲的基本功能任何圖形與互動類別都滿足特定功能關係，這種想法讓生活和設計得到了大幅簡化。

  <img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240409163122965.png" alt="image-20240409163122965" style="zoom:50%;" />

  - Factory Method 角色：

    - `Creator`：抽象工廠類。
    - `ConcreteCreator`：具體工廠類。
    - `Product`：抽象產品類。
    - `ConcreteProduct`：具體產品類。

    `Creator` 就是工廠方法，`ConcreteCreator` 是實現了 `Creator` 的具體工廠方法，每一個具體工廠方法生產一個具體的產品 `ConcreteProduct`，每個具體的產品都實現通用性產品的特性 `Product`。



- 弊端

  工廠方法中，每創建一種具體的子類，就要寫一個對應的 `ConcreteCreate`，這相對比較笨重，如果將創建多個對象放到一個 `ConcreteCreate` 中，就變成了簡單工廠模式，新增捵品要修改已有類不符合開閉模式。

  彼之毒藥吾之蜜糖，要知道沒有一種設計模式解決所有問題，沒有一種設計模式沒有弊端，而這個弊端不代表這個設計模式不好，一個弊端的出現可能是為了解決另一個痛點。要接受不完美的存在，這麼多設計模式就是對應了不同的業務場景，為合適的場景選擇一種能將優勢發揚光大，以至於能掩蓋弊端，就算進行了合理的架構設計。

  

- 總結

  工廠方法並不是簡單把 new 的過程換成了函數，而是抽象出一套面向介面的設計模式：

  <img src="https://ask.qcloudimg.com/http-save/yehe-4823808/1a72f50af9bc4708c5a1eba47a8232d4.png" alt="img" style="zoom:80%;" />

  要做燈泡，可以直接做具體的燈泡，也可以定義一個燈泡接口，透過燈泡工廠拿到具體燈泡，燈泡工廠對待所有燈泡的製作過程都是一樣的，不管是中世紀風燈泡，還是復古風燈泡，亦或是普通白織燈砲，都是一模一樣的製作流程，具體怎麼做由具體的子類別去實現，這樣我們可以統一管理 "燈泡" 這一個通用概念，而忽略不同燈泡之間不太重要的差別，程式的可維護性大幅提升。



### 3. 抽象工廠模式（Abstract Factory）

![image-20240307100218229](/Users/migo.weng/Library/Application Support/typora-user-images/image-20240307100218229.png)

- 定義說明：

  抽象工廠核心結構有四個角色。

  1. 抽象工廠 `AbstractFactory`：

     擔任這個角色的是抽象工廠模式的核心，它是與應用程式無關的。任何在模式中創建對象的工廠類必須實現這個接口。

  2. 具體工廠 `ConcreteFactory`：

     擔任這個角色的是實現了抽象工廠接口的具體 class 類，具體工廠角色含有與應用密切相關的邏輯，並且受到應用程式的調用以創建產品對象。

  3. 抽象產品 `AbstractProduct`：

     工廠方法模式所創建的對象的超類型，也就是產品對象的共同父類或共同擁有的接口。

  4. 具體產品 `ConcreteProduct`：

     這個角色實現了抽象產品角色所申明的接口。工廠方法模式所創建的每一個對象都是某個具體產品角色的實例。

     

- 意圖：

  為了更好理解抽象工廠模式，先引入兩個概念：

  <img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240322141251825.png" alt="image-20240322141251825" style="zoom:50%;" />

  <img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240322141904740.png" alt="image-20240322141904740" style="zoom:55%;" />

  1. 產品等級結構：

     產品等級結構即產品的繼承結構，如一個抽象類別是電視機，其子類別有海爾電視機、海信電視機、TCL電視機等，則抽象電視機與具體品牌的電視機之間構成了一個產品等級結構，抽象電視機是父類，而具體品牌的電視機是其子類。

  2. 產品族：

     在抽象工廠模式中，產品族是指由同一個工廠生產的，位於不同產品等級結構中的一組產品，如海爾電器工廠生產的海爾電視、海爾電冰箱，海爾電視機位於電視機產品等級結構中，海爾電冰箱位於電冰箱產品等級結構中。

     

- 抽象工廠模式定義：

  > 提供一個介面以建立一系列相關或相互依賴的對象，而無須指定它們特別的類別。

<img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240322144057995.png" alt="image-20240322144057995" style="zoom:50%;" />

- 抽象工廠模式結構與分析：

  <img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17170ec2577083b3~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt="img" style="zoom:95%;" />

  

- 抽象工廠模式包含以下角色：

  - AbstractFactory：抽象工廠。
  - ConcreteFctory：具體工廠。
  - AbstractProduct：抽象產品。
  - ConcreteProduct：具體產品。

<img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240322142431309.png" alt="image-20240322142431309" style="zoom:50%;" />

<img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240322142440368.png" alt="image-20240322142440368" style="zoom:50%;" />

<img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240322142450784.png" alt="image-20240322142450784" style="zoom:50%;" />



- 意圖解釋：

  1. 情景 - 汽車工廠

  我們都知道汽車有很多零件，隨著工業革命帶來的分工，很多零件都可以輕鬆取代。但實際生活中我們消費者不願意這樣，我們希望買來的寶馬車所包含的零件都是同一系列的，以保證最大的匹配度，從而帶來更好的性能與舒適度。

  所以消費者不願意到輪胎工廠、方向盤工廠、車窗工廠去一個個採購，而是將需求提給了寶馬工廠這家抽象工廠，由這家工廠負責組裝。那你是這家工廠的老闆，已知汽車的組成部件是固定的，只是不同配件有不同的型號，分別來自不同的製造廠商，你需要推出幾款不同組合的車型來滿足不同價位的消費者，你會怎麼設計？

  2. 情景 - 迷宮遊戲

  你做一款迷宮遊戲，已知元素有房間、門、牆，他們之間的組合關係是固定的，你透過一套演算法產生隨機迷宮，這套演算法調用房間、門、牆的工廠生成對應的實例。但隨著新資料片的放出，你需要產生具有新功能的房間（可以回復體力）、新功能的門（需要魔法鑰匙才能打開）、新功能的牆（可以被炸彈破壞），但修改已有的迷宮生成演算法違背了開閉原則（需要在已有物件進行修改），如果你希望生成迷宮的演算法完全不感知新材料的存在，你會怎麼設計？

  3. 情景 - 事件聯動

  假設我們做一個前端搭建引擎，現在希望做一套關聯機制，以實現點擊表格元件單元格，可以彈出一個模態框，內部展示一個折線圖。已知業務方存在定製表格元件、模態框元件、折線圖元件的需求，但元件之間連動關係是確定的，你會怎麼設計？

  

  在汽車工廠的例子中，我們已知車子的構成部件，為了組裝成一輛車子，需要以一定方式拼裝部件，而巨體用什麼部件是需要可拓展的。

  在迷宮遊戲的例子中，我們已知迷宮的組成部分是房間、門、牆，為了產生迷宮，需要以某種演算法產生許多房間、門、牆的實例，而具體用哪種房間、哪一種門、哪一種牆是這個演算法不關心的，是需要可被拓展的。

  在事件連動的例子中，我們已知這個表格彈出趨勢圖的互動場景基本上組成元素是表格元件、模態框元件、折線圖元件，需要以某種連動機制讓這三者間產生連動關係，而具體是什麼表格、什麼模態框元件、什麼折線圖元件是這個事件連動所不關心的，是需要可以被拓展的，表格可以被替換為任意業務方註冊的表格，只要滿足點擊`onClick` 機制就可以。

  這三個例子不正是符合上面的意圖嗎？我們要設計的抽象工廠就是要創造一系列相關或相互依賴的對象，在上面的例子中分別是汽車的組成配件、迷宮遊戲的素材、事件連動的組件。而無須指定它們具體的類，也就說明了我們不關心車子方向盤用的是什麼牌子，迷宮的房間是不是普通房間，聯動機制的折線圖是不是用畫 `Echarts` 的，我們只要描述好他們之間的關係即可，這帶來的好處是，未來我們拓展新的方向盤、新的房間、新的折線圖時，不需要修改抽象工廠。

  ![image-20240306135835494](/Users/migo.weng/Library/Application Support/typora-user-images/image-20240306135835494.png)

  `AbstractFactory` 就是我們想要的抽象工廠，描述了創造產品的抽象關系，例如描述迷宮如何生成，表格和趨勢圖怎麼連結。至於具體用什麼方向盤、用什麼房間，是由 `ConcreteFactory` 實現的，所以我們可能會有多個牆壁。比如 `ConcreteFacrory1` 實例化的牆壁是普通牆壁，`ConcreteFactory2` 實例化的牆壁是魔法強壁，但其對 `AbstractFactory` 的接口是一致的，所以 `AbstractFactory` 不需要關心具體調用的是哪一個工廠。

  `AbstractProduct` 是產品抽象類，描述了例如方向盤、牆壁、折線圖的創建方法，而 `ConcreteProduct` 是具體實現產品的方法，例如 `ConcreteProduct1` 創建的表格是用 `canvas` 畫的，折線圖是用 `G2` 畫的，而 `ConcreteProduct2` 創建的表格是用 `div` 畫的，折線圖是用 `Echatrs` 畫的。

  這樣，當我們要拓展一個使用 `svg` 畫的表格 ， `Rcharts` 畫的折線圖時，只需要再創建一個 `ContcreteProduct3` 做相對應的實現即可，再將這個 `ContcreteProduct` 傳遞給 `AbstractFactory`，並不需要修改 `AbstractFactory` 方法本身。

  

- 弊端：

  任何設計模式都有其適用場景，反過來也說明了在某些場景下不適用。

  根據上面的三個情景，如果我們的需求不是拓展一個新輪子、新牆壁、新折線圖，而是：

  - 汽車工廠要為汽車增加一個零件：自動駕駛系統。
  - 迷宮遊戲要新增一個功能材料：限阱。
  - 事件連動要新增一個連動物件：明細趨勢統計表。

  像這種情況不是為已有元素新增一套實現，而是實現一些新元素，就會非常困難，因為我們不僅要為所有 `ConcreteFactory` 新增每一個元素，還要修改抽象工廠，以將新元素與舊元素間建立聯繫，違反了開放封閉原則。

  因此，對於已有元素固定的系統，適合使用工廠模式，反之不然。

  

- 總結：

  抽象工廠模式對新增現有產品的實現實用，對新增一個產品的種類不適用，可以參考結合了情景的下圖加深理解：

  <img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240306174355336.png" alt="image-20240306174355336" style="zoom:50%;" />

  拓展一個熔岩素材包是增家一種產品風格，適合使用抽象工廠設計模式 ; 拓展一個陷阱是增家一個產品種類，不適合使用抽象工廠設計模式，為什麼呢？看下圖：

  <img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240306175023031.png" alt="image-20240306175023031" style="zoom:50%;" />

  創建迷宮這個抽象工廠做的事情，是把已有的房間、門、牆壁建立關聯，因此操作的是抽象類，所以拓展一套具體實現（熔岩素材包）對這個抽象工廠沒有感知，這樣做很容易。

  但如果新增一個產品種類 - 陷阱，可以看到，抽象工廠必須將陷阱與前三者重新建立關聯，這就要修改抽象工廠，不符合開放封閉原則。同時，如果已有素材包 1~ 999 個，就需要同時增加 1~ 999 個對應的陷阱實現（普通陷阱、魔法陷阱、熔岩陷阱），其工作量會非常大。 

  因此，只有產品種類穩定時，需要頻繁拓展產品風格時，才適合使用抽象工廠設計模式。



## 結構型模式

### 1. 外觀模式（Facade）

<img src="https://ithelp.ithome.com.tw/upload/images/20181029/20112528NteGp12xG0.png" alt=" Facade Pattern" style="zoom:60%;" />

- 意圖：

  為子系統中的一組接口提供一個一致的界面，Facade 模式定義了一個高層接口，這個接口使得這一子系統更容易使用。

  為降低一個擁有多個接口的子系統內部複雜性，我們需要一個外觀來屏蔽內部的複雜性，因此外觀模式就是定義一個高層接口，這個接口直連子系統的內部實現，但掉用這個高層接口的人不需要關心子系統內部的實現，這樣，對於不想了解子系統內部實現的人來說，提高了易用度。

  當然如果想要深度定制，就可以繞過外觀模式，直接使用子系統提供的類，所以說並不是有了外觀模式就必需通過外觀調用，而是根據實際需要判斷使用哪種調用方式。

  

- 意圖解釋：

  圖書館是一個非常複雜的系統，雖然圖書按照一定規則擺放，但也只有內部人員比較清楚，作為一位初次來的訪客，想要快速找到一本書，最好的辦法是直接問圖書管理員，而不是先了解這個圖書館的設計，因為你可能要來回在各個樓宇間奔走，借書的流程可能也比較長。

  圖書館員就起到了簡化圖書館子系統複雜度的作用，我們只要凡事詢問圖書館員即可，而不需要關心他是如何與圖書館內部系統打交道的。

  

- 弊端：

  外觀模式並不適用所有場景，當子系統夠易用時，再使用外觀模式就是畫蛇添足。另外，當系統難以抽象出通用功能時，外觀模式的設計可能也無所適從，因為設計的高層介面可能適用範圍很窄，此時外觀模式的意義就比較小。

  

- 總結：

  其實抽象工廠模式也可以取代外觀模式，來實現隱藏子類別具體實現的效果，但外觀模式描述更具通用性。



### 2. 適配器模式（Adapter）

<img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240222180358825.png" alt="image-20240222180358825" style="zoom:50%;" />

<img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240222174249241.png" alt="image-20240222174249241" style="zoom:50%;" />

- 定義說明：

  - Target（轉接的介面）：

    定義著所需要的方法，可以是抽象類別或是介面。如：國外的插座。（白話文：想要變成的對象）

  - Adapter（實作）：

    為呼叫和配接的元件中的組合接口。如：身上電器插頭。（白話文：想變身的對象）

  - Adapted（提供的類別）：

    為一個轉換器，通過繼承或是合成的方式，將 Adaptee 的接口轉換成 Adapter 接口，Client 直接呼叫 Adapter 接口就可以執行 Adaptee 的方法。如：轉接頭。（白話文：把想變身的對象變成它想變成的對象）

    

- 意圖：

  適配器模式通常用來：

  - 介面不相容（Interface Incomplatibility）：

    當有一個現有的類別，它提供了一個介面，但這個介面與你需要的介面不相容時，可以使用 Adapter 模式。Adapter 模式將現有類別的介面轉換為符合你需求的新介面。

    

  - 重用現有類別（reusing Existing Classes）：

    當想要重用一個已經存在的類別，但它的介面不符合你的需求時，Adapter 模式允許你將這個類別包裝起來，使其能夠與其他代碼協同工作，而不需要修改原有的類別。

    

  - 將多個類別整合為一個介面（intergrating Multiple Classes into One Interface）：

    有時你可能需要將多個不同的類別整合成一個統一的介面，以簡化客戶端代碼。Adapter 模式可以實現這種整合。

    

  總之，Adapter 模式的主要目的是使不相容的介面能夠共同工作，同時還可以重用現有的程式碼，提高程式碼的可維護性和擴展性。

  

- 意圖解釋：

  介面轉換器的概念，譬如插座的種類很多，我們都用過許多轉接頭，將不同的插頭轉換，可以在不替換插座的情況下正常使用。

  USB 介面轉換也同樣精彩，有將 TypeC 介面轉換成 TypeA 的，也有將 TypeA 介面轉換成 TypeC 的，支援雙向轉換。

  介面轉換器就是我們在生活種使用到的適配器模式，因為廠商並沒有生產一個新的插座，我們也沒有因為接口不適配而換一個手機，一切只需要一個接口轉換器（接頭轉換器）即可。

  

  因此適配器模式需滿足下面兩個條件：

  - 介面不相容：插座與插頭不相容。

  - 但能力已支援：插座都擁有充電或讀取能力。

    

- 弊端：

  使用適配器模式本身就可能是個問題，因為一個好的系統內部不應該做任何橋界，模型應該保持一致性。只有在如下情況才考慮使用適配器模式：

  1. 新舊系統接替，改造成本非常高。

  2. 三方包適配。

  3. 新舊 API 相容。

  4. 統一多個類別的介面，一般可以結合工廠方法使用。

     

- 總結：

  適配器模式也符合開放封閉原則，在不對原有物件改造的前提下，建構一個適配器就能完成模組銜接。適配器模式的實作分為類別與物件模式：

  - 類別模式：繼承。

  - 物件模式：組合。

    

### 3. 橋接模式（Bridge）

<img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240304150816305.png" alt="image-20240304150816305" style="zoom:40%;" />

- 意圖：

  > 將抽象部份與它的實作部份分離，使它們可以獨立地變化。

  橋接模式可將業務邏輯或一個大類拆分為不同的層次結構，從而能獨立地進行開發。

  層次結構中的第一層（通常稱為抽象部份）將包含對第二層（實現部份）對象的引用。抽象部份能將一些（有時是絕大部份）對自己的調用委派給現實部份的對象。所有的實現部份都有一個通用接口，因此它們能在抽象部份內部相互替換。

  

- 意圖解釋：

  「抽象」部份與「實作」部份分離，這句話看比來很像介面與實作。確實，如果「抽象」指的是介面（interface），而實作指的是類別（class）的話，這就是簡簡單單的 `class MyWindow implements Window` 類別實作過程而已。

  但後半句話「使它們可以獨立地變化」會讓你難以和前半句聯繫起來，如果說「抽象」不變，「實作」可以隨意改變還好理解，但反過來就難以解釋了。

  其實橋接模式中，抽象指的是一種介面（abstraction），實作指的也是一種介面（implementor），其中implementor 並不是直接實作了 abstraction 定義的接口，而是提供更底層的方法，使 abstraction 可以基於它們封裝出自己的介面實作。

  這樣一來，abstraction 的介面可以隨意變化，畢竟呼叫的是 implementor 提供的函數的組合，只要 implementor 提供的功能全面，implementor 可以不變，對應的，implementor 的實作也可以隨意變化，只要提供的底層函數不變，就不影響 abstraction 對其的使用。

  <img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240304151022462.png" alt="image-20240304151022462" style="zoom:50%;" />

  

  - Abstraction：定意抽象類別的介面。

  - RefindedAbstraction：擴充 Abstraction（extends）。

  - Implemenotr：定義實作類別的接口，該介面可以與 Abstraction 介面不致。

  - ConcreteImplementor：實作 Implementor 介面並定義它的具體實作（implements）。

    抽象部份就是 Abstraction，實作部份就是 implementor，在這個結構圖中，它們是分離的，可以各自獨立變化，橋街模式，就是指 `imp` 這個橋，透過 Implementor 實現 Abstraction 接口，就算是橋接上了，這種組合的橋接相比普通的類別實現更靈活，更具有拓展性。



- 弊端：

  不要過度抽象，橋接模式是為了讓類別的職責更單一，維護更便捷，但如果只是小型項目，橋接模式會增家架構設計的複雜度，而且不正確的模組拆分，把本來關聯的邏輯強制解耦，在未來會導致更大的問題。

  另外橋接模式也有簡單與複雜模式之分，只有一種實現的場景就不要用抽象工廠做過度的封裝了。

  

- 總結：

  橋接模式讓我們重新審視類別的設計是否合理，把類別中不相關，或者說互相獨立的維度抽出去，由橋接模式做橋接的方式使用，這樣會使每個類別功能更內聚，程式碼更少更清晰，組合能力更強大，更容易做拓展。



### 4. 裝飾器模式（Decorator）

- 意圖：

  > 動態地為一個物件添加一些額外的職責。就增加功能來說，Decorator 模式相比產生子類別更為靈活。

  說明例子：

  1. 相框：

     照片＋相框 = 相框的照片，這背後就是一種裝飾器模式：照片具有看的功能，相框具有裝飾功能，在你看照片的基礎上，還能看到精心設計的相框，增加了美感，同時相框還可以增加照片的保存時間與安全性。

     

  2. 帶有快取的文件讀寫：

     假設我們有一個類別 `FileI0` 用來讀寫文件，但是沒有快取功能，此時是新建一個 `CachedFileI0` 子類別好，還是創建一個 `CachedI0` ?

     一眼看上去好像 `CachedFileI0` 用起來更方便，而 `CacheI0` 的用法是 `new CachedI0(new FileI0())` 稍為麻煩一些，但如果我們增加一個網絡讀寫類 `NetworkI0`，一個數據庫讀寫類 `DBI0` 呢？

     顯然，繼承的方式會使子類別數量極速膨脹，而組合的方式則非常靈活，生成一個支援快取的網路讀寫器，只需要 `Nnew CahedI0(new NetwrokI0())` 即可，這就是組合靈活的地方。

     當然，為了實現這個能力，`CachedI0` 需要與 `FileI0`、`CachedFileI0`、`CahaedI0` 繼承自同一個類，具備相同的介面。

     

  3. 搭建平台的元件 Wrapper：

     裝飾器模式別名也叫 `wrapper`，`wrapper` 也常在前端搭建場景中遇到，當搭建平台載入一個元件時，希望拓展其基礎能力，一般會使用 `wrapper` 層對元件進行嵌套，`wrapper` 層就是在不改變 API 的基礎上，對第三方組件進行增強。	

  

- 意圖解釋：

  > 動態地為一個物件添加一些額外的職責。就增加功能來說，Decorator 模式相比產生子類別更為靈活。

  不同於繼承，組合可以在運行時進行，所以稱之為「動態添加」，這裡的「額外職責」泛指一些功能，比如在按鈕點擊時進行一些 log 日誌的打印，在繪製 text 文本框時，額外增加一個捲軸和邊框等等。

  「就增加功能來說，Decorator 模式相比生成子類別更為靈活」這句話的含義是，組合比繼承靈活，當可拓展的功能很多時，繼承方案會產生大量的子類，而組合可以提前寫好處理函數，在需要時動態建構，顯然是更靈活的。

  <img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240325113721155.png" alt="image-20240325113721155" style="zoom:50%;" />

  `ConcreteComponent` 指的是需要被裝識的組件，可以看到，裝飾器 `Decorator` 與他都繼承同一個類，這樣能保證 API 的一致，才能保證無論裝飾多少層，始終符合 `Component` 類型。

  裝飾器如果有多種，就要將 `Decorator` 申明為抽象類，`ConcreteDecoratorA`、`ConcreteDecoratorB` 分別實現它們，如果只有一種裝飾器，可以退化到 `Decorator` 自身就是一種實現。

  

- 適用場景：

  - 想不修改原有代碼，並在運行時為對象添加額外的行為。

  - 難以通過繼承來擴展對象時。

  - ES7 新增的 decorator，通過 @decorator 類似的關鍵字和方法添加裝飾器。

    

- 分析：

  - 符合單一職責原則，額外添加的裝飾器都保持完成自身一項職責。
  - 符合開放封閉原則，無需修改原有代碼，增量增加裝飾器即可。
  - 可以用多個裝飾器實現鏈式調用，動態組合行為。

  

- 弊端：

  裝飾器的問題也是組合的問題，過多的組合會島導致：

  - 組合過程複雜，要產生過多的物件。
  - 包裝器層次增多，會增加調試成本，比較難追溯一個 bug 是在哪一層包裝導致的。

  

- 總結：

  裝飾器是非常常用的模式，Decorator 是一個透明的包裝，只要確保包裝的透明性，就可以最大限度地發揮裝飾器模式的優勢。

  



## 行為型模式

### 1. 策略模式（Strategy）

<img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240227144022063.png" alt="image-20240227144022063" style="zoom:50%;" />

​								<img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240227145049192.png" alt="image-20240227145049192" style="zoom:55%;" />

- 定義說明：

  - Context：封裝上下文，根據需要調用所需的策略，屏蔽外界對策略的直接調用，只對外提供一個接口，根據需要調用對應的策略。

  - Strategy：策略，含有具體的演算法，其方法的外觀相同，因此可以互相替換。

  - StrategyMap：所有策略的集合，供封裝上下文呼叫。

    

- 意圖：

  > 定義一系列的演算法，把它們一個個封裝起來，並且使它們可以互相替換。本模式使演算法可以獨立於使用它的客戶而變化。

  策略是形象的表述，所謂策略就是方案，我們都知道任何式情都有多種方案，而且不同方案都能解決問題，所以這些方案可以互相替換。我們將方案從問題中抽象化出來，這樣就可以拋開問題，單獨優化方案了，這就是策略模式的核心。

  

- 意圖解釋：

  演算法可以理解為策略，我們制定許多解決某個場景的策略，這些策略都可以獨立的解決這個場景的問題，這樣下次遇到這個場景時，我們就可以選擇任何策略來解決，而且我們還可以脫離場景，單獨優化策略，只要介面不變即可。

  這個意圖本質上就是解耦，解耦之後才可以分工。想想一個複雜的系統，如果所有策略都耦合在業務邏輯裡，那麼只有懂業務的人才能小心翼翼的維護，但如果將策略與業務都解耦，我們可以獨立維護這些策略，為業務帶來更靈活的變化。
  
  <img src="/Users/migo.weng/Library/Application Support/typora-user-images/image-20240227151423201.png" alt="image-20240227151423201" style="zoom:50%;" />
  
  - Strategy：策略的公共介面。
  - ConcreteStrategy：具體策略，實作了上面這個介面。



- 弊端：

  不要走極端，不要每個分支有一個策略模式，這樣會導致策略類過多，當分支邏輯簡單且清晰好維護時，不需要使用策略式抽象化。

  

- 總結：

  策略模式是很重要的抽象思維，我們首先要意識到問題有許多種解法，才能意識到策略模式的存在。當一個問題需要採取不同策略，且策略相對複雜，且未來可能要拓展新策略時，可以考慮使用策略模式。



### 2. 觀察者模式（Observer）

- 意圖：

  > 定義物件間的一種一對多的依賴關係，當一個物件的狀態改變時，所有依賴它的物件都會被通知並被自動更新。

  例1：npm 依賴

  npm 套件與專案是一對多的關係（一個 npm 套件被多個專案使用），當 npm 套件發布ㄒ新版本時，如果所有依賴它的專案都能得到通知，並自動更新這個套件的版本號，那麼就解決了套件版本更新的問題，這就是觀察者模式要解決的基本問題。

  

  例2：物件與視圖雙向綁定

  觀察者模式在最初提出的時候，就舉了資料與 UI 相互綁定的例子。即同一份資料可以同時渲染為表格與長條圖，那麼當操作表格更新資料時，如何讓長條圖的資料也刷新呢？從這個場景引出了對觀察者模式的定義，即「數據」與「UI」是一對多的關係，我們需要一種設計模式實現當「數據」變化時，所有依賴於它的「UI」都得到通知並自動更新。

  

  例3：拍賣

  拍賣由一個拍賣員與多位拍賣者組成。排賣時，由 a 喊出競價（出100）就是觀察者向目標發出的 `setStatus`，同時，此時拍賣員喊出（有人出價100，還有更高的嗎？）就是一個 `notify` 通知行為，拍賣員通知了現場競價全員，刷新了他們對當前最高價的信息。

  

  例4：聊天室

  聊天室由一個中央伺服器與多個客戶端組成。客戶端發送訊息後，就是向中央伺服器發送了 `setStatus` 更新請求，此時中央伺服器通知所有處於同一聊天室的客戶端，更新他們的訊息 `notify`，從而完成一次訊息的發送。

  

- 意圖解釋：

  Observer Pattern 實作的原理就是把獲取資料的部份抽離出來，並在資料改變時，同步發送給所有的觀察者。且觀察者可以在任何時候決定是否要繼續接資料。

  當多個 class 都需要接收同一種資料的變化時，就適合使用 Observer Pattern。

  - 多個 class => 觀察者 Observer。

  - 同一種資料 => 主題 Subject。

    ![img](https://fullstackladder.dev/assets/blog/mastering-rxjs-06-observer-pattern/03.png)

  - 觀察者模式基本上只有兩個角色：

    - 觀察者（Observer）：
      - `notify`：當目標資料變更，會呼叫觀察者的 notify 方法，告知資料變更了。
    - 目標/主題（Subject）:
      - `notifyObservers`：用來通知所有目前的觀察者資料變更了，也就是呼叫所有觀察者物件的 `notify` 方法。
      - `addObserver`：將某個物件加入觀察者清單。
      - `deleteObserver`：將某個物件從觀察者清單移除。

  

- 弊端：

  不要拘泥於實現形式，一對多的關係不一定要用這種代碼組織形式來實現觀察者效果。也可以利用 proxy 模式輕鬆實作。

  

- 總結：

  觀察者模式是非常常用的設計模式，它描述了物件一對多依賴關係下，如何通知並更新的機制，這種機制可以用在前端 UI 與資料映射、後端的請求與控制器映射。平台間的訊息通知等大部份場景，無論實現或程式中，存在依賴且需要通知的場景非常普遍。



### 3. 模版模式（Template Method）

- 意圖

  > 定義一個操作中的演算法的骨架，而將一些步驟延遲到子類別。Template Method 使得子類別可以不改變一個演算法的結構即可重定義該演算法的某些特定步驟。

  當要完成某個過程，該過程要執行一系列步驟，而這一系列步驟的基本邏輯相同但個別步驟在實現時可能不同的情況下，通常考慮使用模版方法模式來處理。

  - 舉個例子：

    1. 模版文件：

       我們辦事列印的文件就是模版文件，只需要寫上個人基本資料再簽字就可以了，不需要做太多的重複勞動，因為某些場景下大部份內容是可以固化下來的。例如：買賣房屋，那大部份甲方乙方的條款是固定的，最大的變化是甲方與乙方的不同，我們在模版上簽字時，就是利用了模版式減少了大量的寫條款的時間。

       

    2. 實例化：

       實例化也可以被認為是模版模式的某種表現形式，因為對於工廠方法，我們傳入不同的初始值可能給出不同結果，那麼實際上就是用很少的程式碼撬動了很大一塊功能，起到了抽象作用。

       

    3. Angular 模版：

       Angular 模版更符合我們對模畚直覺的理解。在這個場景中，模版指的是 HTML 模版，只需要在模版中以 `{{}}` 形式描述一些變量，就可以生成一塊只有局部變量變化的模版 DOM，非常方便。

  

- 意圖解釋

  > 定義一個操作中的演算法的骨架，而將一些步驟延遲到子類別。Template Method 使得子類別可以不改變一個演算法的結構，即可重定義該演算法的某些特定步驟。

  這個設計模式初衷是用於物件導向的，所以考慮的是如何在類別中運用模版模式。先定義一個父類，實作一些演算法，再將需要被子類重載的方法提出來，子類重載這部份方法後，即可利用父類實作好的演算法做一些功能。

  比方說父類別方法 `function a(){ b() + c()}` ，此時子類別只需要重定義 `b` 與 `c` 方法，即可重覆使用 `a` 的演算法（b 與 c 的相加）。當然這個例子比較簡單，當演算法較為複雜時，模版模式的好處就會凸顯出來。

  <img src="https://ask.qcloudimg.com/http-save/yehe-4823808/6617301d295f78807bfa851e46ab9693.png" alt="img" style="zoom:50%;" />

  - `ConcreteClass`：具體的父類別，可以看到父類別中實作了 `TemplateMethod`，其呼叫了 `PrimitiveOperation1` 與 `PrimitiveOperation2`，所以子類別只需要重載這兩個方法，即可享用 `TemplateMethod` 提供的演算法。

    假設 `TemplateMethod` 是 `OpenDocument` 開啟文件的作用，那麼 `PrimitiveOperation1` 可能是 `CamOpen` 校驗，`PrimitiveOperation2` 可能是 `ReadDocument` 讀取文件的方法。

    我們只需要專心實現具體的細節方法，而不需要關心他們之間是如何互動的，父級會幫我們實現它。之後我們就可以呼叫子類別的 `OpenDocument` 實作開啟文件了。

  

- 弊端

  模版模式在類別中，本質上是固定不可變的結構，進逼步縮小重寫方法的範圍，重寫的範圍越小，程式碼可重覆使用度就越高，所以一定要在具有通用演算法可提取的情況下使用，不要為了節省程式碼行數而過度使用。

  另外前端開發中，HTML 本身就很契合模版樣式，因為 HTML 中有大量標籤描述千變萬化的 UI 結構，可復用的地方實在太多太多，所以非常適合模板模式，所以不要認為模版模式僅能在類別中使用，模版模式還能在鷹架中使用呢，例如填入一些表單自動產生程式碼。

  學習這個設計模式時，請注意不要固化思維在其定義的類這個框子中，因為設計模式寫於 1994 年，其中提到的模式已經被大量遷移使用，能否識別並做適當的知識遷移。是 20 多年後的今天學習設計模式的關鍵。

  

- 總結

  模版模式與策略模式有一定相似處，模版模式是改變演算法的一部份，而策略模式是將策略完全提取出來，所以可以改變演算法的全部。
